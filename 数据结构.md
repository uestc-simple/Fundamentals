# 一、绪论

### 数据结构三要素

1. 逻辑结构：**线性**与**非线性**

2. 存储结构：顺序存储、链式存储、索引存储、散列存储

3. 数据的运算

###  算法效率的度量

1. 空间复杂度
2. 时间复杂度

# 二、线性表

## 顺序表

线性表的顺序存储称为顺序表，其特点为逻辑顺序与物理顺序相同

线性表元素从1开始，数组元素下标从0开始

## 链表

### 单链表

#### 定义

线性表的链式存储称为单链表

```c++
//单链表结点定义
typedef struct LNode{
    ElemType data;
    struct LNode *next;
}Node,*LinkedList;
```

> 头指针：指向第一个结点（头结点或首元结点）
>
> 头结点：链表首元结点前附设的结点，指针指向首元结点；不计入链表长度

#### 基本操作

1. 建立单链表

   <img src="https://github.com/uestc-simple/image/blob/main/408/ds_2_2.png?raw=true" alt="头插法建立单链表" style="width: 55%;" />

   ```C++
   //头插法
   scanf("%d",&x);
   while(){
       s=(LNode*)malloc(sizeof(LNode));	//创建结点
       s->data=x;
       s->next=L->next;					//新结点插入表头
       L->next=s;							//头指针指向首元结点
       scanf("%d",&x);
   }

<img src="https://github.com/uestc-simple/image/blob/main/408/ds_2_3.png?raw=true" alt="头插法建立单链表" style="width: 60%;" />

```c++
   //尾插法
   scanf("%d",&x);
   while(){
       s=(LNode*)malloc(sizeof(LNode));	//创建结点
       s->data=x;
       r->next=s;							//尾指针指向新结点
       r=s;								
       scanf("%d",&x);
   }
```


2. 查找

3. 插入

   ```c++
   p=GetElem(L,i-1);		//插找插入位置的前驱结点
   s->next=p->next;
   p->next=s;
   ```

4. 删除

   ```c++
   p=GetElem(L,i-1);		//插找插入位置的前驱结点
   q=p->next;
   p->next;
   ```

5. 求表长

### 双链表

1. 插入

   <img src="https://github.com/uestc-simple/image/blob/main/408/ds_2_4.png?raw=true" alt="头插法建立单链表" style="width: 50%;" />

   ```c++
   //将*s插入*p后
   s->next=p->next;
   p->next->prior=s;
   s->prior=p;
   p->next=s;
   ```

2. 删除

   <img src="https://github.com/uestc-simple/image/blob/main/408/ds_2_5.png?raw=true" alt="头插法建立单链表" style="width: 55%;" />

   ```c++
   //删除*p的后继结点*q
   p->next=q->next;
   q->next->prior=p;
   free(q);
   ```

### 循环链表

1. 循环单链表
   * 循环单链的*r结点指向L
   * 判断循环单链表表空 不是头结点的指针为空，而是```head->next=head```

2. 循环双链表

### 静态链表



# 三、栈、队列、数组

## 栈

### 栈的基本概念

* 卡特兰数（Catalan）：n个元素出栈入栈的排列个数  $ \frac {1} {n+1} C{^n_{2n}}$

### 栈的顺序存储

1. 顺序栈

   ```c++
   typedef struct{
       ElemType data[MaxSize];
       int top;
   }Sqstack;
   
   //初始栈顶指针：S.top=-1	
   //栈空条件：S.top=-1
   //栈满条件：S.top=MaxSize-1
   //进栈：top加1，再送入值    
   //出栈：先取值，再top减1
   ```
2. 共享栈
	```c++
	//top0=-1时，0号栈空
	//top1=MaxSize时，1号栈空
	//栈满：top1-top0=1
	```

### 栈的链式存储

* 采用链式存储的栈称为 **链栈**，优点是方便共享，且不易溢出

  ```c++
  typedef stuct LinkNode{
      ElemType data;
      struct LinkNode *next;
  }LiStack;
  
  //初始时：front=rear=0
  //进队：队不满，先送值，再队尾指针加1
  //出队：队不空，先取值，再队头指针加1
  ```



### 栈的应用

1. 表达式求值
2. 括号匹配
3. 递归


### 队列的顺序存储

* 队列的顺序存储

  ```c++
   typedef struct{
       ElemType data[MaxSize];
       int front,rear;	//队头、队尾指针
   }SqQueue;
  
  ```

* 循环队列

  ```c++
  //初始：Q.front=Q.rear=0
  //队列长度：(Q.rear-Q.front+MaxSize)%MaxSize
  
  ```

  * 区分循环队列队满和队空的三种处理方法

    1. 牺牲一个单元；**约定队头指针在队尾指针下一位为队满**

       ```c++
       //队满条件：(Q.rear+MaxSize)%MaxSize=Q.front
       //队空条件：Q.front=Q.rear
       //元素个数：(Q.rear-Q.front-MaxSize)%MaxSize
       ```

    2. 增设表示元素个数的数据成员
       ```c++
       //队空：Q.Size==0
       //堆满：Q.size==MaxSize
       ```
    3. 增设tag数据成员
    
       ```c++
       //队空：tag==0
       //堆满：tag==1
       ```

### 队列的链式存储

* 队列的链式存储

  ```c++
  typedef struct LinkNode{	//队列结点
      ElemType data;
      struct LinkNode *next;
  }LinkNode;
  typedef struct{	//链式队列
      LinkNode *front,*rear;	//队列的头指针和尾指针
  }LinkQueue;
  ```

  

* 链式队列的基本操作

### 双端队列

* 双端队列：允许两端都可以入队出队的队列
* 输入受限双端队列：允许一段删除，允许另一端插入和删除
* 输出受限双端队列：允许一段插入，允许另一端插入和删除

### 队列的应用

1. 层序遍历
2. Spooling技术
3. 操作系统的 **进程管理、内存管理**



## 数组



# 四、串

# 五、树

# 六、图

# 七、查找

# 八、排序



